---
title: "Tijdsreeksen"
author: "David D'Haese"
date: "Gepubliceerd op `r Sys.Date()`"
output: 
  html_document: 
      highlight: zenburn
css: "css/labo.css"
---

```{r setup, include=FALSE}
library(knitr)

# Code van https://community.rstudio.com/t/showing-only-the-first-few-lines-of-the-results-of-a-code-chunk/6963/2
hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
  lines <- options$output.lines
  if (is.null(lines)) {
    return(hook_output(x, options))  # pass to default hook
  }
  x <- unlist(strsplit(x, "\n"))
  more <- "..."
  if (length(lines)==1) {        # first n lines
    if (length(x) > lines) {
      # truncate the output, but add ....
      x <- c(head(x, lines), more)
    }
  } else {
    x <- c(more, x[lines], more)
  }
  # paste these lines together
  x <- paste(c(x, ""), collapse = "\n")
  hook_output(x, options)
})
```

## Inleiding

In deze workshop krijg je te zien hoe je tijdsreeksgegevens grafisch kunt voorstellen. We zullen zien dat het weergeven van zulke gegevens nauw verweven is met de verwerking ervan. Omdat meeste analyse tools hier ook gebruik van maken zullen onze gegevens omzetten naar de `ts` klasse. We gaan ook zien hoe je een voorspelling op tijdsreeksgegevens best in grafiek zet.

## Start

Indien je dit nog niet eerder hebt gedaan moet je de meest recente versies van [R](https://cran.r-project.org/bin/windows/base/) en [RStudio](https://rstudio.com/products/rstudio/download/) downloaden en installeren.

## Nieuw project

Je kan ook zonder, maar het is beter om een project-folder te definiëren. Helemaal rechtsboven in RStudio, onder het kruisje om de applicatie te sluiten, vind je een keuzelijst met daarin de mogelijkheid om een nieuw project te creëren. Volgens de wizard en maak een project aan in een folder naar keuze. Het is wel best om voor deze workshop lokaal te werken.

## Nieuw rapport

We werken standaard met het principe van elektronische notitieboeken (eng: _notebooks_) om dat dit de reproduceerbaarheid verhoogt maar ook gewoon omdat het plezieriger werkt. Het formaat daarvoor is een RMarkdown bestand (extensie `.rmd``). Ga als volgt te werk:

1. Maak een nieuw notitieboek aan via de eerste knop linksboven in de knoppenbalk: _New File > R Markdown_
2. Geef een titel op voor het HTML document. HTML is de standaard keuze maar je merkt dat er veel meer keuze bestaat
3. Het kan zijn dat RStudio de eerste keer vraagt om een aantal pakketten te downloaden. Antwoord dan 'ja' en laat de installatie rustig voltooien
4. Je merkt dat RStudio een voorbeeld bestandje heeft aangemaakt
5. Druk nu op de _Save_-knop of gebruik de sneltoets `Ctrl + S` om het bestand in de project-folder te bewaren (gebruik de sneltoets `Alt + Shift + K` voor een overzicht van andere sneltoetsen)
6. Het bestand gaan we meteen eens _uitvoeren_ of 'knitten' door op de knit-knop te drukken

Als alles goed gaat wordt er een voorbeeld rapportje gegenereerd en in de _viewer_-pane getoond.

## Data opladen

Op het einde van de workshop krijg je de kans om met dezelfde dataset als voor de Boxplot-workshop te werken, maar omdat die gegevens zich iets moeilijker lenen voor tijdreeksanalyse, gaan we eerst met een eenvoudigere datasets van start.

Op [Kaggle](https://www.kaggle.com) vind je de dataset genaamd 
[Time Series Data](https://www.kaggle.com/yugagrawal95/timeseries-data). De data wordt als een Excel werkboek beschikbaar wordt gemaakt. Excel is vaak erg problematisch als databron, dus als je het kan vermijden, gebruik dan het liefst een formaat dat binnen 2000 jaren nog steeds begrepen gaat worden: platte tekst, liefst tab-gescheiden (`.tsv`, tab-separated values) zodat inhoudelijke komma's niet ge-escaped moeten worden met dubbele aanhalingstekens.

Voor het opladen van de data gebruiken we `data.table`. Dat is op dit ogenblik de meest professionele manier om data te manipuleren. De `fread` methode is flexibel en laat toe om:

- zeer snel en zeer grote datasets op te laden
- tekst rechtstreeks als data te parseren (i.e. `fread("A,B\n1,2\n3,4")`)
- te bepalen welke variabelen en instanties te selecteren
- een shell commando uit te voeren voor de voorbewerking 
- te bepalen als welke data type de variabelen geïnterpreteerd moeten worden
- de tekencodering van een bestand mee te geven (i.e. `UTF-8`)
- de primaire sleutel te definiëren in geval van relationele data
- een archiefbestand mee te openen (i.e. `fread("dev.gz")`)

1. In je nieuw Rmd bestand, verwijder je de voorbeeld code en plaats je onderstaande code:

```rmd
---
title: "Timeseries"
author: "Jouw naam hier"
date: "Gepubliceerd op `r Sys.Date()`"
output: 
  html_document: 
    highlight: zenburn
---

## Workshop tijdsreeksen

...
```

1. Geef jouw naam in en vervang `...` met een nieuwe R codeblok (eng: _code chunk_):
1. Selecteer `...` en gebruik de sneltoets `Ctrl + Alt + I`
1. Zorg ervoor dat er voor én na elke codeblok, titel en opsomming een lege lijn wordt toegevoegd
1. Plaats in deze eerste blok:

```{r message=FALSE, warning=FALSE}
library(readxl)
library(data.table)
library(magrittr)
library(dplyr)
library(ISOweek)

opts_chunk$set(echo = TRUE)

sales <- read_excel("dat/sales.xlsx", sheet = "Final")
str(sales)
```

- Maak daar

Met de `str` functie kijken we snel naar de inhoud. Zulk een functie wordt typisch in de console uitgevoerd en maakt dan geen onderdeel uit van het rapport zelf:

```{r view-object, output.lines = 15}

par(bg = 4)
library(readxl)

```

## Kleuren

```{r}

palette(c("grey", "steelblue1", "black", "#D3EAF1"))
```


```{r}

sales <- sales %>%
  setDT %>% 
  dcast(Date~Key, value.var = "Volume") %>%
  setDT(sales)

sales_ts <- sales[Date < "2020-02-01", .(A, C, E)] %>%
  ts(freq = 12, start = c(2014, 1))

sales_ts %>% plot

# par(bg = "#D3EAF1")
sales_ts %>% acf(lag.max = 18)
```


```{r}
sales_ts[,"C"] %>% stl(s.window = "periodic") %>% plot

```


```{r}
library("forecast")
ramp <- colorRampPalette(1:2)(25) 

for(series_name in sales_ts %>% colnames) {
  series <- sales_ts[, series_name]
  fc <- series %>%
    window(end=c(2019, 1)) %>%
    forecast(fan = TRUE, h = 12)
  fc %>% plot(shadecols = ramp, lwd = 2, col = 3)
  abline(v = 2019, lwd = 2, col = 3, lty = 2)
  fc <- series %>%
    window(start=c(2018, 12)) %>% lines(lwd = 2, col = 3)
}
```


## Herbemonsteren van temporele gegevens

Temporele gegevens zijn vaak georganiseerd op week, maand, kwartaal of jaarbasis. Bijvoorbeeld verkoopcijfers per kwartaal.  In het vakjargon spreekt met van een _bucket_ van bijvoorbeeld een week, een kwartaal, enz&hellip;. Soms echter, zoals bij onze data, is er wel een datum veld voorzien, maar zijn dedata niet netjes geaggregeerd naar zulke vaste tijdseenheid. De aggregatie, die men ook wel _resampling_ of _bucketising_ noemt, moeten we dan nog manueel uitvoeren. 

```{r}

sem_1_anon <- fread("dat/sem_1_anon.tsv")


## eenmalig >>>

# col_types[col_types == "logical"] <- "numeric"
# col_types <- col_types %>% unlist
# sem_1_anon <- read_excel("dat/sem_1_anon.xlsx", col_types = col_types)
# 
# sem_1_anon %>% fwrite("dat/sem_1_anon.tsv", sep = "\t")
## <<< eenmalig
sem_1_anon <- fread("dat/sem_1_anon.tsv")
par(bg = "#D3EAF1")
# 
# sem_1_anon[, plot(Datum1, Totaal_taalvaardigheid)] 
# sem_1_anon[, plot(Datum1, Totaal_rekenvaardigheid)] 
# sem_1_anon[, plot(Datum1, KritiS_T)] 
# sem_1_anon[, plot(Datum1, ToepS_T)] 
# sem_1_anon[, plot(Datum1, SameL_T)] 
# sem_1_anon[, plot(Datum1, ZelfR_T)] 
# sem_1_anon[, plot(Datum1, PlanR_T)] 
# sem_1_anon[, plot(Datum1, StuuR_T)] 
# sem_1_anon[, plot(Datum1, ZelfE_T)] 
# sem_1_anon[, plot(Datum1, AutoM_T)] 
# sem_1_anon[, plot(Datum1, Cont_M)] 
# sem_1_anon[, plot(Datum1, AM_T)] 
# sem_1_anon[, plot(Datum1, RelaS_T)] 
# sem_1_anon[, plot(Datum1, AnalS_T)] 
# sem_1_anon[, plot(Datum2, MemoS_T)] 

sem_1_anon$Datum1 %>%
  range(na.rm = TRUE) %>%
  strftime("%Y-W%V-1") %>%
  ISOweek2date %>%
  add(c(0, 7))

sem_1_anon[, Week_T := Datum1 %>% ISOweek %>% factor]
week_lev_all <- sem_1_anon$Week_T %>% levels

par(bg = "#D3EAF1", mar = c(5, 5, 6, 2), xpd = TRUE)
sem_1_anon[, plot(Datum1, MemoS_T, col = Week_T, pch = 19,
  cex = .7)]

legend(x = 1.601e9, y= 9, legend =week_lev_all, col = ramp,
  cex = .7, bg = NA, ncol = 4, pch = 19)



library(lubridate)
sem_1_anon[grepl("2020", Week_T), .(MemoS_T = mean(MemoS_T)), Week_T] %>%
  arrange(Week_T) %>%
  select(MemoS_T) %>% 
  ts(freq = 365.25/7,
    start = decimal_date(ymd("2020-09-07"))) %>%   plot(lwd = 2)
# 
# 
# sem_1_anon[, .(Datum1, Week_T)]
# zelfr_t <- sem_1_anon[,
#   .(ZelfR_T = median(ZelfR_T, na.rm = TRUE)), Week_T]
# zelfr_t$Week_T %>% range(na.rm = TRUE)
# zelfr_t$Week_T %>% min(na.rm = TRUE)
# zelfr_t[order(Week_T),
#   ts(ZelfR_T, freq = 365.25/7, start = min(Week_T, na.rm = TRUE))] %>% 
#   plot
# 
# sem_1_anon$Departement %>% table %>% sort %>% rev
# 
# sem_1_anon[, order(Woordenschat)]
# 
# sem_1_anon[Departement %in% c("WT", "MC")]
# 
# sem_1_anon[1:2248]
```


