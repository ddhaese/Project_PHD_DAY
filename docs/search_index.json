[["index.html", "Social Network Summary", " Social Network David DHaese Published on 2021-03-16 Summary This workshop will provide you with the basics on visualizing your data using the statistical package R. The workshop will focus on how to generate frequently used graphics, such as the scatter plot, the (ordered) bar chart or the box and whisker plot. Participants will be able to practice via exercises. Basic knowledge of R is recommended, and R-studio should be installed prior to the session. A simple dataset will be provided, but participants can also use their own research-data. "],["getting-started.html", "Workshop 1 Getting started 1.1 Installation 1.2 New project 1.3 New RMarkdown report", " Workshop 1 Getting started 1.1 Installation In case you havent done this before, install the latest version of R and RStudio 1.2 New project You can do without but it is considered good practice to define a project folder and corresponding R project, no matter how small the project. On the top of the screen in RStudio you will find the button to allow you create a new project or quickly switch between projects. Follow the RStudio wizard to create a new project in a folder of your choice (best locally during workshop) 1.3 New RMarkdown report By default data scientists work with notebooks and for R this means RMarkdown notebook (.rmd extension). Not only do notebooks offer enhanced reproducibility. Once you get used to them, you will find them increasing your productivity: Make a new rMarkdown file through New File &gt; R Markdown Give your HTML document a title (HTML is the default doc type but there are many more) If your RStudio asks for it, let it install the necessary packages You will notice that RStudio has made an example file for you Use the Save-button or Ctrl + S to save it in the root of your project folder (b.t.w., use Alt + Shift + K for an overview of available shortcuts) Let us immediate test the parsing of the report. Run or knit it by pressing the knit-button or use the shortcut Ctrl + Shift K If all goes well, you should see the example report appearing in the viewer pane of your RStudio. "],["boxplot.html", "Workshop 2 Boxplot 2.1 Start 2.2 Nieuw project 2.3 Nieuw rapport 2.4 Data opladen 2.5 Woordenschat 2.6 Departement 2.7 De boxplot", " Workshop 2 Boxplot 2.1 Start Indien je dit nog niet eerder hebt gedaan moet je de meest recente versies van R en RStudio downloaden en installeren. 2.2 Nieuw project Je kan ook zonder, maar het is beter om een project-folder te definiëren. Helemaal rechtsboven in RStudio, onder het kruisje om de applicatie te sluiten, vind je een keuzelijst met daarin de mogelijkheid om een nieuw project te creëren. Volg de wizard en maak een project aan in een folder naar keuze Het is wel best om voor deze workshop lokaal te werken. 2.3 Nieuw rapport We werken standaard met het principe van elektronische notitieboeken (eng: notebooks) om dat dit de reproduceerbaarheid verhoogt en gewoon ook veel plezieriger werkt. Het formaat daarvoor is een RMarkdown bestand. Maak een nieuw notitieboek aan via de eerste knop linksboven in de knoppenbalk: New File &gt; R Markdown en dan een titel opgeven voor een HTML document aan te maken (HTML document is de standaard keuze). Het kan zijn dat RSTudio de eerste keer vraagt om een aantal pakketten te downloaden. Antwoord dan ja en laat de installatie rustig voltooien. Je merkt dat RStudio een voorbeeld bestandje heeft aangemaakt. Druk nu op de Save-knop of gebruik de sneltoets Ctrl + S om het bestand in de project-folder te bewaren (gebruik de sneltoets Alt + Shift + K voor een overzicht van andere sneltoetsen). Het bestand gaan we meteen eens uitvoeren of knitten door op de knit-knop te drukken. Als alles goed gaat wordt er een voorbeeld rapportje gegenereerd en in de viewer-pane getoond. 2.4 Data opladen TODO: Herkomst data Er zijn in R meerdere manieren om data op laden. De eenvoudigste is om via de gebruikersinterface van RStudio te werken. Die doe je via Environment &gt; Import Dataset &gt; From Excel. Het kan zijn dat RSTudio de eerste keer ook hier vraagt om een aantal pakketten te downloaden. Antwoord dan weerom ja en de installatie rustig voltooien. Open het Excel bestand dan je kan terugvinden op deze locatie: https://github.com/ddhaese/Project_PHD_DAY/tree/main/dat Je zal merken dat het in de R console de volgende code verschijnt, dit is de code die de Import Dataset wizard genereert zodat je de code laten kunt hergebruiken om bijv. in een automatisch script te verwerken: library(readxl) sem_1_anon &lt;- read_excel(&quot;dat/sem_1_anon.xlsx&quot;) View(sem_1_anon) De data wordt bewaard in het object sem_1_anon en als je gaat kijken onder de Environment tab, zo je inderdaad dit object moeten zien staan. De laatste lijn opent de dataset meteen in de viewer van RStudio. Voor kleine en middelgrote datasets is dit een snelle manier om de data te exploreren. Merk op dat je in de viewer het data type kan achterhalen door met je muis over de naam van de variabele (= kolom) te hoveren. Je kan in de Environment-tab ook het object openklappen om die informatie te zien. Een derde manier om snel de inhoud van eender welk object in R te bekijken is met de str functie. Geef in de console de volgende code op en je zou een lange lijst moeten zien verschijnen met de variabele namen en geassocieerd data types, de lengte van de kolom en de eerste waarden. Je ziet ook dat het object van het type tibble is, een soort tabel afgeleid van een data.frame. # In de console: str(sem_1_anon) ## tibble [3,811 x 71] (S3: tbl_df/tbl/data.frame) ## $ ID : num [1:3811] 1 2 3 4 5 6 7 8 9 10 ... ## $ Inschrijving : chr [1:3811] &quot;Nee&quot; &quot;Nee&quot; &quot;Nee&quot; &quot;Nee&quot; ... ## $ Generatiestudent : chr [1:3811] &quot;Nee&quot; &quot;Nee&quot; &quot;Nee&quot; &quot;Nee&quot; ... ## $ Departement : chr [1:3811] &quot;MC&quot; &quot;MC&quot; &quot;MC&quot; &quot;MC&quot; ... ## $ Opleiding : chr [1:3811] &quot;Bachelor in het bedrijfsmanagement (rechtspraktijk)&quot; &quot;Bachelor in het office management&quot; &quot;Bachelor in het communicatiemanagement&quot; &quot;Bachelor in het office management&quot; ... ## $ Opleidingstype : chr [1:3811] &quot;Bachelor&quot; &quot;Bachelor&quot; &quot;Bachelor&quot; &quot;Bachelor&quot; ... ## $ Woordenschat : num [1:3811] 70 65 60 60 45 70 55 50 65 95 ... ## $ Lidwoorden : num [1:3811] NA 80 76 62 66 NA 78 NA 92 82 ... ## $ Werkwoordspelling : num [1:3811] NA 73.3 60 73.3 73.3 ... ## $ Algemene_spelling : num [1:3811] NA 52.5 77.5 60 55 NA 65 NA 82.5 NA ... ## $ Woordvorming : num [1:3811] NA 34 36 50 14 NA 32 NA 28 46 ... ## $ Tekstanalyse : num [1:3811] NA 70 80 65 70 NA 65 NA NA NA ... ## $ Correcte_taal : num [1:3811] NA 60.9 69.6 78.3 65.2 ... ## $ Email : num [1:3811] NA 60 90 50 40 NA 30 NA NA NA ... ... In je nieuw Rmd bestand, verwijder je de voorbeeld code, i.e. alles vanaf ## R Markdown. Maak dan een nieuw titeltje aan ## TODO: TITEL WIJZIGEN met daarna een lege lijn. Druk dan op het icoontje om codeblok (eng: code chunk) in te voegen en kies in de keuzelijst voor R-code. Plak dan de gegenereerde code uit de console in deze codeblok zodat je de volgende twee blokken krijgt: ```{r setup, include=FALSE} library(readxl) ``` ```{r load-data} sem_1_anon &lt;- read_excel(&quot;dat/sem_1_anon.xlsx&quot;) View(sem_1_anon) ``` 2.5 Woordenschat Elke rij in de dataset stelt een student voor en elke kolom een eigenschap die op die student van toepassing is. Laten we een aantal van die eigenschappen eens van naderbij onderzoeken. Het is tenslotte belangrijk om een beeld te vormen van de data. We beginnen met het laden van een aantal pakketten. Plak deze code na de vorige library-statement, zodat al de dependencies vooraf gekend zijn. library(readxl) library(data.table) library(magrittr) library(dplyr) Het opladen van de pakketten zal enkel functioneren als de pakketten ook op jouw pc zijn geïnstalleerd. Voer indien nodig de onderstaande code eenmalig uit in de console: # In de console (enkel eenmalig bij eerste gebruik): install.packages(c(&quot;data.table&quot;, &quot;magrittr&quot;, &quot;dplyr&quot;)) Nu kunnen we bijvoorbeeld de variabele woordenschat onderzoeken. We isoleren de variabele uit de sem_1_anon dataset en gebruiken een speciale operator teken van magrittr (%&gt;%) om het resultaat door te geven aan de hist-functie (men spreekt van method chaining of piping). Daarna voegen we een lijn toe ter hoogte van de 50% om te accentueren dat de grote meerderheid van de studenten voor deze proef geslaagd was. De kleuren worden centraal beheert met de fucntie palette zodat we op één plek de kleuren van onze plots kunnen wijzigen. Dus, col = 1 betekent aliceblue en col = 2 staat voor black. palette(c(&quot;aliceblue&quot;, &quot;black&quot;)) sem_1_anon$Woordenschat %&gt;% hist(main = &quot;Verdeling score woordenschat&quot;, xlab = &quot;Score&quot;, ylab = &quot;Aantal studenten&quot;, col = 1) abline(v = 50, lwd = 2, col = 2) 2.6 Departement Laten we nu eens onderzoeken welke departementen vertegenwoordigd zijn in de gegevensset. sem_1_anon$Departement %&gt;% table %&gt;% sort %&gt;% rev %&gt;% barplot(main = &quot;Verdeling per departement&quot;, xlab = &quot;Department&quot;, ylab = &quot;Aantal studenten&quot;, cex.names = .7, cex.axis = .9, col = 1) We zien dat een aantal departementen amper vertegenwoordigd zijn. Die laten we eruit. In de eerste lijn zetten we het tibble object om naar een data.table object d.m.v. de setDT functie. Daarna tellen we het aantal studenten (met speciale functie .N) per departement, selecteren we de departementen waarvoor méér dan 5 studenten antwoorden en bewaren we het resultaat in het object dep_top. sem_1_anon &lt;- setDT(sem_1_anon) dep_top &lt;- sem_1_anon[, .N, Departement][N &gt; 5, Departement] dep_top ## [1] &quot;MC&quot; &quot;WT&quot; &quot;GW&quot; &quot;OT&quot; 2.7 De boxplot We kennen de globale verdeling van de scores voor woordenschat en we weten welke van de 4 departmenten we willen bestuderen. Nu kunnen we een boxplot uittekenen: sem_1_anon %&gt;% filter(Departement %in% dep_top) %&gt;% boxplot(Woordenschat ~ Departement, data = ., col = 1, pch = 19, cex = .5, main = &quot;Verdeling score woordenschat per departement&quot;) abline(h = 50, lwd = 2, col = 2) "],["time-series.html", "Workshop 3 Time Series 3.1 Introduction to time series 3.2 Uploading the data 3.3 Colors 3.4 Data exploration 3.5 Prepare data 3.6 Graphing time series 3.7 Time series analyzes 3.8 Decompose time series 3.9 Predictions 3.10 Extra: Resampling temporal data", " Workshop 3 Time Series 3.1 Introduction to time series In this workshop we will learn how to handle and visualize temporal data. Most analytic tools dealing with time series depend on the ts class of objects and so we will have to learn how to transform our source data to a ts object. Finally, we will be plotting the results of some diagnostic and predictive analyses typical for time series data. 3.2 Uploading the data At the end of the workshop you will have the opportunity to work with the same dataset as for the Boxplot workshop, but because that data is slightly more difficult to use for time series analysis, we will first start with a simpler dataset. On Kaggle you will find the dataset called [Time Series Data] (https://www.kaggle.com/yugagrawal95/timeseries-data). The data is originally made available as an Excel workbook, but we will be using the same data converted into a tsv file. This dataset consists of the sales figures of a number of products along with several other variables that will not be used here. Excel is often very problematic as a data source, so if you can avoid it, preferably use a format that will still be understood 2000 years from now: plain text, preferably tab-separated values (.tsv) so that values with commas need not to be escaped with double quotes. We use data.table to upload the data. This package currently offers the most professional way to manipulate data. The fread method is flexible and allows you to: load very fast and very large datasets parse text directly as data (i.e. fread (\"A,B\\n1,2\\n3,4\")) select variables as well as instances run a shell command to add a pre-processing step set the data type the variables should be interpreted as include the character encoding of a file (i.e. UTF-8) define the primary key in case of relational data directly open data from within an archive (i.e. fread (\"dev.gz\")) In your new Rmd file, delete the sample code and add the code below: --- title: &quot;Timeseries&quot; author: &quot;Your name here&quot; date: &quot;Published on 2021-03-16&quot; output: html_document: highlight: zenburn --- ## Workshop Time Series ... Enter in your name and replace ... with a new R code block (eng: code chunk) using the shortcut Ctrl + Alt + I Make sure in a rMArkdown file to add an empty line before and after each code block, title and list Add the code below in this block (additional info to come): library(knitr) library(data.table) library(magrittr) library(readxl) library(dplyr) library(ISOweek) library(lubridate) library(forecast) opts_chunk$set(echo = TRUE) sales &lt;- fread(, &quot;dat/sales.tsv&quot;) With the various library expressions, the necessary packages are loaded into memory. If these lines generate an error, it is usually means the package needs installing first. If so, use an expression such as install.packages (c (\" data.atble \",\" magrittr \")) in the console to install the missing packages. Let us now briefly review why we need these packages: knitr: parsing the RMarkdown to an HTML report data.table: loading and manipulating data magrittr: using [method chaining] (https://en.wikipedia.org/wiki/Method_chaining#:~:text=Method%20chaining%2C%20also%20known%20as,to%20store%20the%20intermediate % 20results.) dplyr: alternative to manipulating data ISOweek: converting from date to week numbers and vice versa, according to [ISO 8601] (https://en.wikipedia.org/wiki/ISO_8601) standards lubridate: expression of a date as a decimal number forecast: wrapper to run forecasts onts objects Note that for demo purposes two alternatives are used here for manipulating data. Also note that a lot of effort is put into manipulating date fields. As we will see, handling dates, especially when the data is classified on a weekly basis, can become very complex very rapidly. With the opts_chunk$set function (actually function set that is an element of the list opts_chunk) we ensure that the source code is shown in the report. If the report is distributed to individuals who are not interested in the code, you can set echo = FALSE. 3.3 Colors Create a color palette: palette(c(rgb(.7, .7, .7), &quot;steelblue1&quot;, &quot;black&quot;, &quot;#D3EAF1&quot;)) The above code demonstrates the use of the color palette. Here you see that you can enter colors in different formats. After the palette has been defined, you can refer to the colors by means of their indices 1, 2, &amp; hellip ;. If you havent yet heard about it, you might want to examine the Munsell color space. Munsell was a genius with colors. A full description of his color space is beyond the scope of this workshop, but why not admire one of his so-called color contrasts (dyads): Figuur 3.1: The dyad blue-5 versus yellow-red-5 (5B-5YR). In each colored box you will see from the top down: an index for reference, the Munsell color code, the corresponding RGB values and finally the color represented as a hex triplet. See the [Wikipedia page] (https://en.wikipedia.org/wiki/Munsell_color_system) for more info and [this page] (https://www.rit.edu/cos/colorscience/rc_munsell_renotation.php) of the Rochester Institute of Technology where you will find datasets to produce similar figures. 3.4 Data exploration We are going to keep data exploration here to a minimum. With the str function you can look inside objects such as this sales object. Such a function is typically executed in the console and is not part of the report itself: # In the console... sales %&gt;% str ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 935 obs. of 86 variables: ## $ Key : chr &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## $ Date : POSIXct, format: &quot;2014-01-01&quot; &quot;2014-01-01&quot; ... ## $ Volume : num 1346974 677826 1210359 436761 434 ... ## $ Disc : num 4.29e+08 1.16e+08 1.04e+08 5.63e+07 2.94e+05 ... ## $ max_T : num 49.5 49.5 49.5 49.5 49.5 ... ## $ min_T : num 29.7 29.7 29.7 29.7 29.7 ... ## $ avg_T : num 39.6 39.6 39.6 39.6 39.6 ... ## $ precipitation : num 0.448 0.448 0.448 0.448 0.448 ... ## $ Consumer_Price_Index_month : num 85.5 85.5 85.5 85.5 85.5 ... ## $ Exchange_Rate_Index_Period_Average_month : num 109 109 109 109 109 ... ## $ Exchange_Rate_LCU_per_US_Period_Average_month : num 6.83 6.83 6.83 6.83 6.83 ... ... We see that there are a number of products (under Key), a date of sale (Date) and sales Volume. As you can see there are many more variables, but with these three we should be able to get started to demonstrate the basics. 3.5 Prepare data The particular thing about time series (but also, for example, GIS data) is that the dependent variables do not only depend on other variables, but also on themselves. We speak of autocorrelation when a value depends on a neighbouring value either through space or time. To conduct a time series in R, you are best to work with ts class objects (stands for time series). In order to do that, we first need to pivot the data: sales &lt;- sales %&gt;% dcast(Date ~ Key, value.var = &quot;Volume&quot;) Date A B C D E F G H I J K L M N 2014-01-01 1346974 677825.9 1210358.5 436760.7 433.99 1229415.4 790802.1 NA NA NA NA NA NA NA 2014-02-01 1058681 442605.0 829241.9 205538.3 699.10 885082.1 507910.2 NA NA NA NA NA NA NA 2014-03-01 1089615 550634.4 1100553.1 262253.8 1421.69 1191730.8 612966.6 NA NA NA NA NA NA NA 2014-04-01 1073261 665210.9 1316461.4 351818.4 1758.77 1357049.5 879226.3 278106.2 NA NA NA NA NA NA 2014-05-01 1289022 811401.7 1515828.5 309505.0 2275.23 1713073.1 1041092.3 389241.8 NA NA NA NA NA NA 2014-06-01 1491953 915308.1 1731305.7 339498.8 2894.75 1887919.4 1292278.0 501514.3 NA NA NA NA NA NA This pivoting is rather exceptional in statistical analyses and is mainly encountered in autocorrelated data (see also the term repeated measures). Now we select three products and also apply a Date filter because some values are missing at the end of the time series. Then we convert the data to a ts object: sales_ts &lt;- sales[ Date &lt; &quot;2020-02-01&quot;, # Filter by date .(A, C, E)] %&gt;% # Selecte features ts(frequency = 12, # Convert to ts, 12 months per year start = c(2014, 1)) # Provide start of the time series 3.6 Graphing time series Once everything is in the correct format, it is as simple as calling the plot function: par(bg = 4, cex.main = 1) main &lt;- &quot;Sales figures\\nfor three products&quot; sales_ts %&gt;% plot(main = main, xlab = &quot;Year&quot;) Close, but no cigar. There is still an issue with the y-axes. The position of the labels on the axes in base R is determined by a functionpretty. So you could turn off the y-axes in the plot (yaxt = \"n\") and plot them all manually using the axis function. Of course, it is much easier to divide the numbers by a factor 1000. Adjust the previous code to divide the sales figures by 1000 and than adjust the title of the figure: sales_ts_th &lt;- sales_ts / 1000 par(bg = 4, cex.main = 1) main &lt;- &quot;Sales figures (x1000)\\nfor three products&quot; sales_ts_th %&gt;% plot(main = main, xlab = &quot;Year&quot;) 3.7 Time series analyzes This is not a workshop on analyses, but in reality the analyses and the visualization go hand-in-hand. After all, visualization often serves as a diagnostics tool. Let us measure the amount of cross-correlation among the sales of our three selected products. Examine the auto- and cross-correlation for all combinations of the sales volumes for the products A, c and E. Do this for a horizon of 18 months in the future (positive) and in the past (negative): par(bg = 4) sales_ts_th %&gt;% acf(lag.max = 18) From this we learn, for example, that there is a correlation between products A and E with a horizon of 1 season (1 year in this case), but that the relationship is not completely symmetrical. In other words one event seems to preceed the other and that may be en important hint to analyse possible causal dependencies. To see this, compare the correlation at 1.0 for A &amp; E (below the dashed blue line indicating the significance level) with that of -1.0 for E &amp; A (above significance level). 3.8 Decompose time series Lets break the sales figures for one product, namely product C, into a seasonal effect (the purely repetitive part), the trend (background level) and the residual noise: par(bg = 4) sales_ts_th[, &quot;C&quot;] %&gt;% stl(s.window = &quot;periodic&quot;) %&gt;% plot Note that the problem of the axes is solved here by alternating the position of the y-axis. Investigate how the plot of a stl object causes the axes to be displayed alternately: stats:::plot.stl 3.9 Predictions Let us predict the future, more specifically the sales figures for the year 2019. Note that we just have those figures, why would we predict them? Because it is of course good to immediately test the prediction against reality, otherwise we have to wait a year and the organizers of this workshop voted against :-) Let us take the standard plot for multivariate forecast objects: par(bg = 4) sales_ts_th %&gt;% forecast %&gt;% plot(col = 3, xlab = &quot;Year&quot;, main = &quot;Items sold (x 1000)&quot;) This is already quite good, but there are some problems. Lets start with an important detail: the color and shades of the prediction intervals. With fan you can obtain more color shades and withcolorRampPalette we make a simple color shade: par(bg = 4) ramp &lt;- colorRampPalette(1:2)(25) sales_ts_th %&gt;% forecast(fan = TRUE) %&gt;% plot(col = 3, xlab = &quot;Year&quot;, shadecols = ramp, main = &quot;Items sold (x 1000)&quot;) Now comes the main problem: we really only want to forecast only 2019 and we want to see the current and forecast data superposed. It would also be nice if there were a clear marking at the start of the prediction. Try to reproduce the predictions with the above requirements: par(bg = 4, mfrow = c(3, 1), oma = c(5, 3, 1, 1), mar = c(0, 4, 0, 2)) for(series_name in sales_ts %&gt;% colnames) { series &lt;- sales_ts_th[, series_name] fc &lt;- series %&gt;% window(end=c(2019, 1)) %&gt;% forecast(fan = TRUE, h = 12) fc %&gt;% plot(shadecols = ramp, col = 3, xaxt = &quot;n&quot;, main = &quot;&quot;) title(ylab = series_name) if (series_name == &quot;E&quot;) { axis(1) } abline(v = 2019, lwd = 2, col = 1, lty = 3) fc &lt;- series %&gt;% window(start=c(2018, 12)) %&gt;% lines(col = 3) } title(xlab = &quot;Year&quot;, outer = 2) 3.10 Extra: Resampling temporal data Temporal data is often organized on a week, month, quarter, or annual basis. For example sales figures per quarter. In the industry we speak of a bucket and the bucket could be a week, a quarter, etc &amp; hellip ;. Sometimes, however, as with the student data, a date field is provided, but the data is not neatly aggregated into fixed time units. The aggregation, which is also called resampling or bucketising, must then be performed manually. This is demonstrated below for the sake of completeness. sem_1 &lt;- fread(&quot;dat/sem_1_anon.tsv&quot;) We first check the range of the variable Date1, divide it into weeks and add seven days to the end date: sem_1$Datum1 %&gt;% range(na.rm = TRUE) %&gt;% strftime(&quot;%Y-W%V-1&quot;) %&gt;% ISOweek2date %&gt;% add(c(0, 7)) By alternating the dot color per week, we can investigate where there is sufficient data available to perform an analysis on: sem_1[, Week_T := factor(ISOweek(Datum1))] week_lev_all &lt;- sem_1$Week_T %&gt;% levels par(bg = 4) ramp &lt;- rainbow(24, 1) temp_pal &lt;- palette(ramp) sem_1[, plot(Datum1, MemoS_T, col = Week_T, pch = 19, cex = .7, main = &quot;Highlight weeks&quot;, xlab = &quot;Date for review version\\n(&#39;terugblikversie&#39;)&quot;, ylab = &quot;Memorising&quot;)] -&gt; d legend(&quot;bottomright&quot;, legend = week_lev_all, col = ramp, cex = .7, bg = NA, ncol = 4, pch = 19, border = &quot;n&quot;) palette(temp_pal) Finally we can select the portion with suffcient data availble and convert to a ts object: par(bg = 4) sem_1[ grepl(&quot;2020&quot;, Week_T), # Selectie .(MemoS_T = mean(MemoS_T)), # Var-manipulatie Week_T] %&gt;% # Groepering arrange(Week_T) %&gt;% # dplyr select(MemoS_T) %&gt;% ts( freq = 365.25/7, start = decimal_date(ymd(&quot;2020-09-07&quot;))) %&gt;% plot(lwd = 2, xlab = &quot;Tijd (decimaal)&quot;, ylab = &quot;Memoriseren&quot;, main = &quot;Evolutie memoriseren&quot;) "],["social-network.html", "Workshop 4 Social network 4.1 Loading the data 4.2 Exploring 4.3 Reducing size 4.4 The network 4.5 Vectors 4.6 Cascading style sheets", " Workshop 4 Social network https://www.kaggle.com/rozemberczki/musae-github-social-network &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ## Introduction to social network ======= ## Introduction &gt;&gt;&gt;&gt;&gt;&gt;&gt; 06ba3f214079fd482a97ebf052461d4458ab62bb In this workshop, we will try to create an interactive force-directed network diagram from the D3.js framework. Typically, this type of graph is adopted for displaying relations within a social network, but its use extend far beyond social sciences. For example, one could device a similar network depicting the correlation among variables of a large dataset (e.g. the results within the students dataset of workshop 1) or, from the realm of NLP, the co-occurrence of words within tweets. 4.1 Loading the data We will be using the MUSAE GitHub Social Network dataset from Kaggle. This data covers the social network of developers on github. The authors provide us with three files, two of which we will need to display the network: a set of nodes containing the name of the developers a set of edges depicting the relationships among developers Start a new project Load the three files containing the data library(data.table) library(magrittr) library(networkD3) edges &lt;- fread(&quot;dat/git_edges.tsv&quot;) nodes &lt;- fread(&quot;dat/git_nodes.tsv&quot;) 4.2 Exploring Explore the two data.table objects using the str command until you understand how these are connected to each other 4.3 Reducing size Unfortunately, visualizing social network is really only feasible with relatively small networks. Once we start talking thousand of nodes, you will need a bigger boat. Not that the D3.js network is slow, it is not. It has to do with the number of edges increasing exponentially with increasing number of nodes. Pick the 40 most popular developers, i.e. the ones with the most connections, andadjust the edges and nodes datasets accordingly popular &lt;- edges %&gt;% unlist %&gt;% table %&gt;% sort %&gt;% rev %&gt;% head(40) %&gt;% names edges_sel &lt;- edges[Source %in% popular &amp; Target %in% popular] edges_sel[, Source := match(Source, popular) - 1] edges_sel[, Target := match(Target, popular) - 1] nodes_sel &lt;- nodes[ID %in% popular] nodes_sel[, ID := match(ID, popular) - 1] 4.4 The network Drawing the network is really easy. Because however it is different from any other plotting system in R, it takes a bit time to get accustomed to. For example, the color palette is being written in Javascript. Start by creating a palette with your two favourite colors palette(c(&quot;#2D859C&quot;, &quot;#B86619&quot;)) Now we have to make sure to generate a string that looks like this: d3.scaleOrdinal(). domain([&quot;0&quot;, &quot;1&quot;]). range([&quot;#2D859C&quot;, &quot;#B86619&quot;]); Generate the above JS code based on the value of the palette color_scale &lt;- paste0( &quot;d3.scaleOrdinal().domain([\\&quot;0\\&quot;, \\&quot;1\\&quot;])&quot;, &quot;.range([\\&quot;&quot;, palette()[1:2] %&gt;% paste0(collapse = &quot;\\&quot;, \\&quot;&quot;), &quot;\\&quot;]);&quot;) Indeed, also the content of the domain function call could be generated from the unique values in the node groups instead of fixing it to contain [\"0\", \"1\"]. Notice the use of escapes for inserting double quotes. Now that we have the colors covered, we can call the forceNetwork function of the networkD3 package. forceNetwork( height = 600, width = 600, Links = edges_sel, Nodes = nodes_sel, Source = &quot;Source&quot;, Target = &quot;Target&quot;, NodeID = &quot;Name&quot;, Group = &quot;Group&quot;, bounded = TRUE, opacityNoHover = .8, linkColour = &quot;#999999&quot;, zoom = TRUE, colourScale = JS(color_scale), legend = TRUE, fontFamily = &quot;Roboto&quot;, fontSize = 20, charge = -1, opacity = 1, linkDistance = 200) Let us go over the arguments one-by-one: &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD - height = 600: set canvas width to 600px - width = 600: set canvas height to 600px - Links = edges_sel: attach edge dataset - Nodes = nodes_sel: attach node dataset - Source = \"Source\": define variable name containing the source of the relationships - Target = \"Target\": define variable name containing the target of the relationships - NodeID = \"Name\": define variable name containing the label to be displayed - Group = \"Group\": define variable name containing the (color) group - bounded = TRUE: wether nodes are allowed to fly out of the canvas - opacityNoHover = .8: the opacity of the labels when no node is being hovered over - linkColour = \"#999999\": the color of the edges - zoom = TRUE: whether the network can be zoomed-in and out - colourScale = JS(color_scale): the JS colorscale - legend = TRUE: whether to add a legend - fontFamily = \"Roboto\": the font family for the labels - fontSize = 20: the font size for the labels - charge = -1: the amount of force that pull the nodes together (positive) or apart (negative) - opacity = 1: the relative opacity of the graph elements - linkDistance = 200: the default length of the edges disregarding forces acting upon the nodes ======= height = 600: set canvas width to 600px width = 600: set canvas height to 600px Links = edges_sel: attach edge dataset Nodes = nodes_sel: attach node dataset Source = \"Source\": define variable name containing the source of the relationships Target = \"Target\": define variable name containing the target of the relationships NodeID = \"Name\": define variable name containing the label to be displayed Group = \"Group\": define variable name containing the (color) group bounded = TRUE: wether nodes are allowed to fly out of the canvas opacityNoHover = .8: the opacity of the labels when no node is being hovered over linkColour = \"#999999\": the color of the edges zoom = TRUE: whether the network can be zoomed-in and out colourScale = JS(color_scale): the JS colorscale legend = TRUE: whether to add a legend fontFamily = \"Roboto\": the font family for the labels fontSize = 20: the font size for the labels charge = -1: the amount of force that pull the nodes together (positive) or apart (negative) opacity = 1: the relative opacity of the graph elements linkDistance = 200: the default length of the edges disregarding forces acting upon the nodes &gt;&gt;&gt;&gt;&gt;&gt;&gt; 06ba3f214079fd482a97ebf052461d4458ab62bb See ?forceNetwork for more details. Mind that the code for the developer type was not clear from the data source, otherwise we could have replaced 0 and 1 by their proper type descriptions and the legend would adjust accordingly. 4.5 Vectors The network is being rendered as an svg HTML element (scalable vector graphics). This has some very interested advantages. For one, it means the texts are not rendered as images, but remain searchable just like any other text on the report. Try to search text within your network (e.g. mcanthony) or that of this workshop page using your browser 4.6 Cascading style sheets Hopefully you have heard of CSS before. It is the language used to style the web and it has been growing more popular in the past decades and will probably continue to do so for a while. Because the network is being rendered as pure HTML, elements of it can also be styled using CSS. In Rstudio, which supports multilingual development, you can add a css code chunk instead of an R code chunk. Add a css code chunk in your report with the following code: g circle { stroke: #999999 !important; stroke-width: 1px !important; } g circle[r=&quot;11&quot;]{ fill: #FD9734; } g circle { stroke: #999999 !important; stroke-width: 1px !important; } g circle[r=\"11\"]{ fill: #FD9734; } "]]
